/*-------------------------------------------------------------*/
/* 示例程序：展示 %LET 与 CALL SYMPUT 创建宏变量及数据步中*/
/* 宏变量解析（编译时替换的特点）*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/* 【1】使用 %LET 语句创建宏变量*/
/* %LET 语句在宏处理阶段立即执行，即在程序编译前创建宏变量。*/
/* 因此，无论后续代码在哪里引用 &compile_val，都显示为已定义的值。*/
/*-------------------------------------------------------------*/
%let compile_val = 50;
%put NOTE: 使用创建宏变量 -> compile_val = &compile_val;

/*-------------------------------------------------------------*/
/* 【2】在 DATA 步中使用 CALL SYMPUT 创建宏变量*/
/* 在数据步执行期间，根据数据计算或条件进行动态赋值。*/
/* 注意：在 DATA 步中的所有宏变量引用（如 &data_val ）*/
/* 都是在数据步执行之前编译时完成替换的。如果在同一个数据步*/
/* 内先调用宏变量引用，再通过 CALL SYMPUT 给该宏变量赋值，*/
/* 数据步中调用宏变量引用处不会得到更新后的值。*/
/*-------------------------------------------------------------*/
data _null_;
    /* 此处的 &data_val 在编译时即已被替换，因之前未定义，故结果为空 */
    put "数据步开始时，data_val 的值为: &data_val";
    
    /* 使用 CALL SYMPUTX 函数，将宏变量 data_val 设置为 100 */
    call symputx('data_val', 100);
    
    /* 此处的 &data_val 在数据步编译时已经替换，所以依旧为空 */
    put "数据步中，调用 CALL SYMPUTX 后的 data_val 的值为: &data_val";
run;

/* 数据步执行完毕后，宏变量 data_val 的值已更新，可在后续代码中正确引用 */
%put NOTE: 数据步执行后 -> data_val = &data_val;

/*-------------------------------------------------------------*/
/* 【3】在新的 DATA 步中引用已更新的宏变量*/
/* 此时，data_val 的值已由上一个 DATA 步计算并赋值为 100，所以*/
/* 在新的数据步中宏变量引用 &data_val 将显示最新的值。*/
/*-------------------------------------------------------------*/
data _null_;
    put "在新的数据步中，data_val 的值为: &data_val";
run;
